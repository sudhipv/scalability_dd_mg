include "getARGV.idp"


ofstream ff("ssinit.edp");

real ordo = getARGV("-ordo", 3);
real ordIN = getARGV("-ordi", 2);
real muG = getARGV("-muG", 0);
real sigmaG = getARGV("-sigmaG", 0.3);

real inPC = ordIN + 1 ;
real outPC = ordo + 1;

ff << "real muG = " << muG << ";" << endl;
ff << "real sigmaG = " << sigmaG << ";" << endl;
ff << "real ordOUT = "<< ordo <<";" << endl;
ff << "real ordIN = " << ordIN << ";" << endl;
ff << "real inPC = " << inPC << ";" << endl;
ff << "real outPC = " << outPC << ";" << endl;


int N = ordo + 1;
assert(N > 0);


// Generating fespace
//fespace Vh(Th, P1, P1, P1, P1);

ff<< "func Pk = [";
for(int i = 0; i < N; ++i) {
    ff << " P1";
    if(i != N-1)
        ff << ",";
    else
        ff << "];";
}
ff << endl;


//Generating macro
//macro def(i)[i, i#1]// EOM          // vector field definition

ff<< "macro def(i)[i,";
for(int i = 0; i < N-1; ++i) {
    ff << " i#"<<i+1;
    if(i != N-2)
        ff << ",";
    else
        ff << "] //EOM";
}
ff << endl;


//macro init(i)[i, i]// EOM           // vector field initialization

ff<< "macro init(i)[";
for(int i = 0; i < N; ++i) {
    ff << "i";
    if(i != N-1)
        ff << ", ";
    else
        ff << "]//EOM";
}
ff << endl;




ofstream fg("ssweakcomp.edp");


// macro UtransV2(u,v)(u*v + u#1 * v#1 + u#2 * v#2) //EOM

fg<< "macro UtransV(u,v)(u*v + ";
for(int i = 0; i < N-1; ++i) {
    fg << "u#" << i+1 << "*" << "v#"<< i+1;
    if(i != N-2)
        fg << " + ";
    else
        fg << ")//EOM";
}
fg << endl;

/*
macro coeffmult3(u,v) ( Cd(0,0) * Grad(u)'*Grad(v) + Cd(0,1) * Grad(u)'*Grad(v#1) + Cd(0,2)*Grad(u)'*Grad(v#2) + Cd(0,3)*Grad(u)'*Grad(v#3) +
                        Cd(1,0) * Grad(u#1)'*Grad(v) + Cd(1,1) * Grad(u#1)'*Grad(v#1) + Cd(1,2)*Grad(u#1)'*Grad(v#2) + Cd(1,3)*Grad(u#1)'*Grad(v#3) +
                        Cd(2,0) * Grad(u#2)'*Grad(v) + Cd(2,1) * Grad(u#2)'*Grad(v#1) + Cd(2,2)*Grad(u#2)'*Grad(v#2) + Cd(2,3)*Grad(u#2)'*Grad(v#3) +
                        Cd(3,0) * Grad(u#3)'*Grad(v) + Cd(3,1) * Grad(u#3)'*Grad(v#1) + Cd(3,2)*Grad(u#3)'*Grad(v#2) + Cd(3,3)*Grad(u#3)'*Grad(v#3)
                         ) //EOM)
*/


fg << "macro coeffmult(u,v)(";

for(int i = 0; i < N; ++i)
{
    for(int j = 0; j < N; ++j)
    {
        fg << endl;
        fg << "Cd(" << i << "," << j << ") * ";

        if(i == 0 )
        {
            fg << " Grad(u)' * ";
        }
        else
        {
           fg << " Grad(u#" << i << ")' * ";
        }

        if(j == 0 )
        {
            fg << " Grad(v) ";
        }
        else
        {
           fg << " Grad(v#" << j << ") ";
        }

        if(i == N-1 && j== N-1)
            fg << ")//EOM";
        else
            fg << " + ";


    }


}

fg << endl;


// [b,b1,b2,b3] = [f,0,0,0];


fg<< "[b,";
for(int i = 0; i < N-1; ++i) {
    fg << "b" << i+1;
    if(i != N-2)
        fg << ",";
    else
        fg << "] ";
}


fg<< "=[f,";
for(int i = 0; i < N-1; ++i) {
    fg << "0";
    if(i != N-2)
        fg << ",";
    else
        fg << "];";
}


fg << endl;


ofstream fh("ssolution.edp");


/*
sol[0] = U;
sol[1] = U1;
sol[2] = U2;
sol[3] = U3;
*/

fh << "sol[0] = U;";
fh << endl;
for(int i = 0; i < N-1; ++i) {
    fh << "sol[" << i+1 << "] = "<< "U"<< i+1 <<";"<< endl;
}

fh << endl;


ofstream fi("ssweakform1.edp");


fi << "varf stoPoisson(def(U), def(V)) = int2d(Th[l])(  coeffmult(U,V) ) + int2d(Th[l])(UtransV(b,V))"+
                                                    "+ on(1,2,3,4, U = 0,";

 for (int i = 1; i < N-1; ++i)
 {

     fi << "U"<<i<<"=0,";


 }

 fi << "U"<<ordo<<"=0);";



ofstream fj("ssweakform2.edp");

fj << "varf stoPoisson(def(U), def(V)) = int2d(Th[l])(  coeffmult(U,V) ) + int2d(Th[l])(UtransV(b,V))"+
                                                    "+ on(7,8,9,10, U = 0,";

 for (int i = 1; i < N-1; ++i)
 {

     fj << "U"<<i<<"=0,";


 }

 fj << "U"<<ordo<<"=0);";















